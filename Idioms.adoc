:toc: macro
:toc-title:
:toclevels: 99
= Idioms and Patterns

toc::[]

= Idioms

== Move and Forward

Move and forward idioms are generally implemented with standard functions `std::move()` and `std::forward()`.
Yet, this is not necessary and plain `static_cast`s are enough.
Functions cost more at compile time and possibly pessimize runtime.
Macros can simplify coding:

```cpp
#define MOVE(...) static_cast<std::remove_reference_t<decltype(__VA_ARGS__)>&&>(__VA_ARGS__)
#define FORWARD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)
```

== Pre-C++20 Concept Detection

Until C++20, there are no formal concepts, but it is still possible to `std::enable` functions according to some named requirements.
For example, let's enable a function `f()` for classes which implement methods `begin()` and `end()` returning an iterator to some `int`-convertible type:

```cpp
template <typename T, typename = void>
struct IsIntRange : std::false_type {};

template <typename T>
struct IsIntRange<T, std::void_t<decltype(std::declval<T>().begin()), decltype(std::declval<T>().end())>> :
    std::is_convertible<decltype(*std::declval<T>().begin()), int> {};

template <typename T>
constexpr bool is_int_range()
{
  return IsIntRange<T>::value; // Sometimes std::decay_t<T> is preferrable to T
}

template <typename T, typename std::enable_if_t<is_int_range<T>()>* = nullptr> // Reduces to void* = nullptr
void f(T& in);
```

= Patterns

== Mixin

Mixins in C++ can be implemented with CRTP:

```cpp
template <typename TDerived>
class SquareMixin {
public:
  int square()
  {
    auto value = static_cast<TDerived>(*this).value();
    return value * value;
  }
};

class Number : public SquareMixin<Number> { // CRTP
public:
  int value()
  {
    return m_value;
  }
private:
  int m_value;
};

auto value = Number{2}.value();
auto square = Number{2}.square();
```
