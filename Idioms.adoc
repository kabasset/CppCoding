:toc: macro
:toc-title:
:toclevels: 99
= Idioms and Patterns

toc::[]

= Move and Forward

Move and forward idioms are generally implemented with standard functions `std::move()` and `std::forward()`.
Yet, this is not necessary and plain `static_cast`s are enough.
Functions cost more at compile time and possibly pessimize runtime.
Macros can simplify coding:

```cpp
#define MOVE(...) static_cast<std::remove_reference_t<decltype(__VA_ARGS__)>&&>(__VA_ARGS__)
#define FORWARD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)
```

= Pre-C++20 Member Detection

Until C++20, there are no formal concepts, but it is still possible to `std::enable` functions according to some named requirements.
For example, let's enable a function `f()` for classes which implement methods `begin()` and `end()` returning an iterator to some `int`-convertible type:

```cpp
template <typename T, typename = void>
struct IsIntRange : std::false_type {};

template <typename T>
struct IsIntRange<T, std::void_t<decltype(std::declval<T>().begin()), decltype(std::declval<T>().end())>> :
    std::is_convertible<decltype(*std::declval<T>().begin()), int> {};
    // or simply std::true_type if detecting return type is not relevant

template <typename T>
constexpr bool is_int_range()
{
  return IsIntRange<T>::value; // Sometimes std::decay_t<T> is preferrable to T
}

template <typename T, typename std::enable_if_t<is_int_range<T>()>* = nullptr> // Reduces to void* = nullptr
void f(T& in);
```

= Mixin (from above)

Mixins in C++ can be implemented with CRTP:

```cpp
template <typename TDerived>
struct SizeMixin {
  std::size_t size() const
  {
    return std::distance(
      static_cast<const TDerived&>(*this).begin(),
      static_cast<const TDerived&>(*this).end());
  }
};

template <typename TDerived>
struct AdditiveMixin {
  template <typename T>
  TDerived& operator+(const T& rhs)
  {
    auto& derived = static_cast<TDerived&>(*this);
    assert(derived.size() == rhs.size());
    std::transform(derived.begin(), derived.end(), rhs.begin(), [](auto l, auto r) {
        return l + r;
      });
    return derived;
  }
};

template <typename TDerived>
TDerived operator+(const AdditiveMixin<TDerived>& lhs, const T& rhs)
{
  TDerived res = static_cast<const TDerived&>(lhs);
  res += rhs;
  return res;
}

template <typename T>
struct Vector : SizeMixin<Vector<T>>, AdditiveMixin<Vector<T>> { // multiple CRTP
  const T* begin() const;
  const T* end() const;
  T* begin();
  T* end();
  ...
};

Vector<int> u(...);
Vector<int> v(...);
auto w = u + v;
```

= Passkey (Restricted Friendship)

Generally, friendship grants access to all the private members of a class.
It is possible to select a set of members only, using a dedicated empty class:

```cpp
class Class {
  class FooKey {
    friend class FooAccessor;
    FooKey() {}
  };

  class BarKey {
    friend class BarAccessor;
    BarKey() {}
  };

  void foo(FooKey);

  void bar(BarKey);
};

struct FooAccessor {
  void foo(Class& c)
  {
    return c.foo({});
  }
};

struct BarAccessor {
  void bar(Class& c)
  {
    return c.bar({});
  }
};
```
